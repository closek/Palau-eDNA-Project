---
title: "Palau eDNA Report Template"
author: 
  - name: "Insert your name here"
date: "`r Sys.Date()`"
format: 
  html:
    number-sections: true
    toc: true
    code-tools: true
    theme: mintly
    number-depth: 1
    self-contained: true
title-block-banner: "#33ccffff"
title-block-banner-color: "#ffdd00ff"
code-fold: true
editor: visual
editor_options: 
  chunk_output_type: inline
execute: 
  echo: false
  warning: false
---

# Document Purpose

This document is a template for analysis and reporting eDNA results. This file is a Quarto document (a newer version of a Rmarkdown file [Intro to a Quarto doc](https://quarto.org/docs/faq/rmarkdown.html){.uri}) that can be opened in Rstudio and used to run code and build a html version of the report. The authors intended this file and larger R project folders & files to document analysis steps, make analyses reproducible, and make future analyses smoother and quicker to run.

There are three components to this document:

1.  **YAML (yet another markdown language) header** - the code contained at the top of this document bounded by a set of `---` marks. This is a place to store document metadata and instructions for how the rest of the quarto doc should run code chunks and format rendered documents. See here for more information --\> [Authoring Docs](https://quarto.org/docs/authoring/front-matter.html){.uri}. We currently have the YAML set so when you Render this document a self-contained .html document will be created, this file format and formatting options can be further customized.

2.  **Code chunks** - code chunks are like mini code scripts. In a quarto doc you can run these individually by clicking on the green arrow/triangle in the upper right corner of the chunk OR using your "run code" shortcut. These chunks are allow to user to write text in between code, and provide instructions on how the code should be incorporated into the rendered document, including how figures should be displayed. See here for more information --\> [Code chunk options (work in both quarto and Rmarkdown docs)](https://quarto.org/docs/computations/execution-options.html){.uri}

3.  **Markdown** - This bullet list is written in markdown. Markdown is a simple text and formatting language. Use this to write text in the rendered report document. Here is a quick guide to markdown syntax --\> [Markdown cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf){.uri}. You can also use values and/or objects generated in your code to populate in your markdown text, see here ---\> [How to use a code value in markdown text](https://www.earthdatascience.org/courses/earth-analytics/multispectral-remote-sensing-modis/add-variables-to-rmarkdown-report/){.uri}

## Code Chunk Example

Below is an example of a code chunk that can run R code. You can set execution options in the YAML (`execute:`)that will be the default options for every code chunk, or you can set them in individual code chunks. More details here --\> <https://quarto.org/docs/computations/execution-options.html>

```{r example-code-chunk}
#| echo: true
#| warning: false

# here is example R code. To write comments within a code chunk, use a # at the beginning of the line, lines with # will not be run within a code chunk.
test <- 1 + 1
test_2 <- test * 6
test_2

# The coding language is indicated in the very first line, within the curly brackets {}. 
# Use `#| ` to set options for the individual code chunk below the first line of the code chunk.

# A code chunk execute option example is `echo: false` this disables the printing of code (only output is displayed in rendered html).

```

# Analysis Template

Below is the code required for eDNA analysis

## Setup 

1)  load packages

We used the `renv` package to manage & record package versions. This records the version of R, package versions, and their dependencies into a file `renv.lock` at the root of this `.Rproj`. The purpose of this is to allow users on different computer setups and in the future to reproduce the results of this project in the same way. This is because different package versions can behave differently version to version, and even introduce errors or produced different results. By using the same exact set of package versions that the authors used to write the code, the same results can be reproduced and prevent unintended errors.

`Renv` creates a separate custom project library that is separate from the system library typically used when the `library()` function is called. This means that when you recreate the `renv` project library by calling `renv::restore()` you will likely need to install many packages. Many may be already installed in your system library, but they will need to be installed again into this custom `renv` project library with the exact version recorded in the `renv.lock` file. All files, folders, and scripts within the `.Rproj` will share the `renv` project library.

For more information about `renv` and how to add/update the `renv` project library -> [ ](https://rstudio.github.io/renv/articles/renv.html).

::: callout-warning
Although this package management strategy is meant to reduce errors among future users, it is not perfect. The authors found that the `renv` project library could not yet be recreated on a M1 chip Apple computer (2023-10).
:::

```{r load-packages}
# load renv packages from project renv.lock file
renv::restore()

library(renv)
library(tidyverse) # this include tidyr, ggplot2, dplyr for data manipulation and graphing
library(vegan)
library(data.table)
library(superheat)
library(calecopal) # color palette
library(viridisLite) # color blind & gray scale friendly color palette
install.packages("cowplot")
library(cowplot) # create graphs with multiple components in a grid
library(fantaxtic)
library(magrittr) # contains pipe function
#devtools::install_github("joey711/phyloseq")
library(phyloseq)
packageVersion("phyloseq")
library(owmr)
library(devtools)
#BiocManager::install("MicrobiotaProcess")
library(MicrobiotaProcess)
library(patchwork)
devtools::install_github("r-lib/conflicted")

```

2)  Create paths to folders

```{r file-directories-paths}
# create file paths to folders within the project for easy & consistent reference throughout the analysis

# path to raw data folder
dir_data_raw <- file.path("./data/raw")
# path to processed / clean data folder
dir_data_proc <- file.path("./data/processed")
# path to code outputs folder
dir_products <- file.path("./products")
# path to code scripts folder
dir_scripts <- file.path("./scripts")
# path to images for report
dir_images <- file.path("./images")

######## create folders if they do not exist
# data folder
if (!dir.exists(file.path("./data/"))) {
  dir.create(file.path("./data/"))
}
# raw data folder
if (!dir.exists(dir_data_raw)) {
  dir.create(dir_data_raw)
}
# processed data folder
if (!dir.exists(dir_data_proc)) {
  dir.create(dir_data_proc)
}
# outputs folder
if (!dir.exists(dir_products)) {
  dir.create(dir_products)
}
# scripts folder
if (!dir.exists(dir_scripts)) {
  dir.create(dir_scripts)
}
# images folder
if (!dir.exists(dir_images)) {
  dir.create(dir_images)
}

```

3) Set analysis date

```{r set-analysis-date}
# set this variable here, used throughout analysis for file naming. Used to differentiate between analyses using the same analysis template on different data
analysis_date <- "2021_11"
```

4) Load data

```{r load-data}
esv_data_all <- read_csv(file.path(dir_data_raw, "JVB1710-MiFishU-read-data.csv"))
# ESV - exact sequence variant

# to see a snippet of the data run the following code in the console 
#glimpse(esv_data_all)
```

## Clean & save data

1) Clean & organize data

The code chunk below "clean-data" be separated into its own `./scripts/clean_data.R` file and sourced by calling `source(file.path(dir_scripts, clean_data.R)` here. If you are looking save space in this analysis document, or want to reuse this exact same data cleaning protocol in different analysis document. The same goes for "create-nearshore-offshore-data" and "create-near-offshore-species-list" chunks, they could be their own scripts or be added to a clean_data script. If you choose to do this, the "example-source-clean-data" chunk below can be used.

```{r example-source-clean-data}
# run data cleaning script
#source(file.path(dir_scripts, "clean_data.R"))

# OR you can choose to only run the script if the output .csv file does not yet exist
# if (!dir.exists(file.path(dir_data_proc, paste0("esv_clean_data_rv_", analysis_date, ".csv"))) {
#   source(file.path(dir_scripts, "clean_data.R"))
# }
```


```{r clean-data}
#Remove preliminary run (i.e., remove duplicated samples "S046...1" that have newer ".2" version) & cleanup columns

data <- esv_data_all %>% 
  select(-c(S046420.1, S046419.1, S046417.1, S046416.1, S046415.1, S046414.1)) %>%
  rename(
    Match_percent = `% match`,
    Species_number = `# species`
  ) 

#head(data) 
#glimpse(data)

### Cobine header row cells into one
#Takes the following row headers: "TestId", "ESVId", "sequence", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "% match", "\# species" Merges them into one "MergedID" with the separator ","

#esv_data_all_mergedrows <- unite(esv_data_all, col='MergedID', c('TestId', 'ESVId', 'sequence', 'Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species', '% match', '# species'), sep=',')

### Collin - is this relevant to all data? How can we generalize this?

####Althea - The S046420.1 is the sample name that Jonah Ventures gave, for this set of data. So, these steps would need to be modified for each sample set.


data_long <- data %>%
  pivot_longer(
    "S049508.1":"S049391.0",
    names_to = "sample",
    values_to = "obs"
  )

# load in sample key & merge with "long" formatted data
samples_key_df <- read_csv(file.path(dir_data_raw, "JVB1710-samples_rv3.csv"))

# join sample keys with data matching by sample
data_long_key_df <- left_join(data_long, samples_key_df, by = "sample")

# Create full sample ID - merge original Sample name w/ the JV sample version name

##### Collin & Althea - convert this to left_join - don't want to do without data loading
left_joined_unite <- data_long_key_df %>%
  unite(col="ID_v", SampleID, sample, sep= "-", 
        remove = TRUE)

# Convert data frame back into "Wide" Format
esv_clean_data <- left_joined_unite %>% 
  pivot_wider(
    names_from = "ID_v", 
    values_from = "obs"
  )

## Identify and verify that higher taxonomic rankings check out
unique(esv_clean_data$Phylum)
#Should only bring back Chordata
#brings back: "Chordata"    ""
#    "" is n=179 unannotated ESVs

unique(esv_clean_data$Class)
#"Actinopteri"    ""               "Mammalia" (n=3spp - false killer whale, spinner dolphin, and pantropical spotted dolphin)      "Chondrichthyes" (n=1spp - Blue shark), "Aves" (n=1spp ~ game fowl/pheasant, chicken)           "Amphibia"  (n=1spp - giant slamander)
#Select for only Classes: Actinopteri and Mammalia, which will remove Classes: Aves and Amphibia, as well as the unannotated ESVs 
#Within Mammalia remove non-marine mammals in  Family: Bovidae, Suidae, Canidae, Felindae, Hominidae and Order: Primates

# save clean data (with analysis date in name)
write_csv(esv_clean_data, file = file.path(dir_data_proc, paste0("esv_clean_data_rv_", analysis_date ,".csv")))

```

2) Read in clean data

```{r read-clean-data}
# read in clean data - used in next 2 code chunks
#(don't have to run clean-data code chunk more than once after clean data is saved, can start here)
esv_clean_data_df <- read_csv(file.path(dir_data_proc, 
                                        paste0("esv_clean_data_rv_", analysis_date, ".csv")))
```

3) Create Nearshore & Offshore dataframes (or load if they already exist)

```{r create-nearshore-offshore-data}
# store file names in objects to reuse & reference. Change here if needed, and will be automatically used through out code
file_offshore_esv <- paste0("offshore_esv_", analysis_date, ".csv")
file_nearshore_esv <- paste0("nearshore_esv_", analysis_date, ".csv")


# if esv file does not exist: run code and save
# if esv file does exist: load file

##### offshore
if (!dir.exists(file.path(dir_data_proc, file_offshore_esv))) {
  # create offshore_esv dataframe
  offshore_esv <- esv_clean_data_df %>% 
    select(2, 6, 7, 8, 9, 10, contains('COS'), contains('AFZ'), contains('DFZ'), contains('NMS'))
  # save dataframe as .csv
  write_csv(offshore_esv, 
            file = file.path(dir_data_proc, file_offshore_esv))
  # if file exists - read it in
} else (offshore_esv <- read_csv(file.path(dir_data_proc, file_offshore_esv)) )

###### nearshore
if (!dir.exists(file.path(dir_data_proc, file_nearshore_esv))) {
  # create offshore_esv dataframe
  nearshore_esv <- esv_clean_data_df %>% 
    select(2, 6, 7, 8, 9, 10, contains('COS'), contains('SHR'), contains('LGN'), contains('FRR'))
  # save dataframe as .csv
  write_csv(nearshore_esv, 
            file = file.path(dir_data_proc, file_nearshore_esv))
  # if file exists - read it in
} else (nearshore_esv <- read_csv(file.path) )

```

3) Create Nearshore & Offshore species lists (or load if they already exist)

```{r create-near-offshore-species-list}
# store file names for reuse
file_offshore_esv_sp <- paste0("offshore_esv_sp_", analysis_date, ".csv")
file_nearshore_esv_sp <- paste0("nearshore_esv_sp_", analysis_date, ".csv")
# similar to code chunk above - if output file already exists, data will load, if not data created

#### offshore species
if (!dir.exists(file.path(dir_data_proc, file_offshore_species))) {
  # create offshore species list
  offshore_esv_sp <- esv_clean_data_df %>% 
    select(2, 10, contains('COS'), contains('AFZ'), contains('DFZ'), contains('NMS'))
  # save dataframe as .csv
  write_csv(offshore_esv_sp, 
            file = file.path(dir_data_proc, file_offshore_species))
  # if file exists - read it in
} else (offshore_esv_sp <- read.csv(file.path(dir_data_proc, file_offshore_esv_sp)))

#### nearshore species
if (!dir.exists(file.path(dir_data_proc, file_nearshore_esv_sp))) {
  #create nearshore species list
  nearshore_esv_sp <- esv_clean_data_df %>% 
    select(2, 10, contains('COS'), contains('SHR'), contains('LGN'), contains('FRR'))
  # save dataframe as .csv
  write_csv(nearshore_esv_sp, 
            file = file.path(dir_data_proc, file_nearshore_esv_sp))
  # if file exists - read it in
} else (nearshore_esv_sp <- read_csv(file.path(dir_data_proc, nearshore_esv_sp)))
```

## Data Analysis

1) Unique Species

```{r unique-species}
#esv_list <- read.csv(here("data/JVB1710-MiFishU-esv-data.csv"),header = TRUE)
#glimpse(esv_list)
#str(esv_list)

#n_distinct(esv_list$Species)
#unique(esv_list$Species)

n_distinct(esv_clean_data$Species)
unique(esv_clean_data$Species)
```

2) Unique Species - nearshore

```{r unique-nearshore-species}
ns_esv <- nearshore_esv[rowSums(nearshore_esv==0, na.rm=TRUE)<ncol(nearshore_esv), ]
#nearshore_esv[rowSums(nearshore_esv[])>0,]
n_distinct(nearshore_esv$Species)
unique(nearshore_esv$Species)

#nearshore_esv_sp_wo0 <- read.csv(here("products/nearshore_esv_sp_wo0.csv"),header = TRUE)
#unique(nearshore_esv_sp_wo0$Species)
#n_distinct(nearshore_esv_sp_wo0$Species)
```

3) Unique Species - offshore

```{r unique-offshore-species}
n_distinct(offshore_esv$Species)
unique(offshore_esv$Species)

#offshore_esv_sp_wo0 <- read.csv(here("products/offshore_esv_sp_wo0.csv"),header = TRUE)
#unique(offshore_esv_sp_wo0$Species)
#n_distinct(offshore_esv_sp_wo0$Species)
```

4) Unique Genera

```{r unique-genera}
#n_distinct(esv_list$Genus)
#unique(esv_list$Genus)

n_distinct(esv_clean_data$Genus)
unique(esv_clean_data$Genus)
```

5) Unique Families

```{r unique-families}
#n_distinct(esv_list$Family)
#unique(esv_list$Family)
#unique

n_distinct(esv_clean_data$Family)
unique(esv_clean_data$Family)

```

#### Thea stopped here

### Transform esv_clean_data into Phyloseq Object

```{r}
names(esv_clean_data)

#create an OTU/ESV count table
esv_read_count <- select(esv_clean_data, -c(1))
esv_read_count <- select(esv_read_count, -c(2:19))
esv_read_count <- data.frame(esv_read_count, row.names = 1)
#names(esv_read_count)
#remove_prefix(esv_read_count, c("X")) %>% names()
class(esv_read_count)
esv_read_count_m <- as.matrix(esv_read_count)
esv_read_count_m
class(esv_read_count_m)

rowSums(esv_read_count)
colSums(esv_read_count)

ESV <- phyloseq::otu_table(esv_read_count_m, taxa_are_rows = TRUE)

#write_csv(ESV, file = file.path("products/ESV.csv"))
#write.csv(ESV, file = "/Users/closek/Documents/Nov2021_PalaueDNA/R/products/ESV.csv")

#create a taxonomy table
esv_read_tax <- select(esv_clean_data, -c(1,3))
esv_read_tax <- select(esv_read_tax, -c(9:195))
esv_read_tax <- data.frame(esv_read_tax, row.names = 1)
class(esv_read_tax)
esv_read_tax_m <- as.matrix(esv_read_tax)
class(esv_read_tax_m)
names(esv_read_tax_m)
TAX <- phyloseq::tax_table(esv_read_tax_m)



#create a sample metadata 
samp_meta <- read.csv(here("data/SampleMetaData.csv"),header = TRUE)
samp_meta_df <- data.frame(samp_meta, row.names = 1)
samp_metadata <- phyloseq::sample_data(samp_meta_df)
class(samp_metadata)

#create phyloseq object
physeq <- phyloseq(ESV, TAX)
physeq

physeq1 <- merge_phyloseq(physeq, samp_metadata)

physeq1
```

### Components of phyloseq object

```{r}
sample_names(physeq1)
rank_names(physeq1)
sample_variables(physeq1)
```

### Subset samples to keep only Environmental samples

```{r}
physeq1 <- subset_samples(physeq1, Control_or_Envtl =="Envtl")
physeq1

```

### Families Barplot with only Environmental samples (excluding Controls)

```{r}
#| label: Fam-Env-samples
#| title: Families from Environmental samples
#| fig-width: 6
#| fig-asp: 0.618
#| out-width: "40%"
#| fig-align: center
#| fig-format: "png"


plot_bar(physeq1, fill = "Family")
```

### Subset to keep only ESVs with marine fish and mammal annotations

```{r}
#Select for only Classes: Actinopteri and Mammalia, which will remove Classes: Aves and Amphibia, as well as the unannotated ESVs 
#Within Mammalia remove non-marine mammals in  Family: Bovidae, Suidae, Canidae, Felindae, Hominidae and Order: Primates
physeq1
physeq1_mar <- subset_taxa(physeq1, Class %in% c("Actinopteri", "Mammalia"))
physeq1_mar
physeq1_mar <- subset_taxa(physeq1, !(Order %in% c("Primates")))
physeq1_mar
physeq1_mar <- subset_taxa(physeq1, !(Family %in% c("Bovidae", "Canidae", "Felindae", "Hominidae", "Suidae")))
physeq1_mar
```

### Sequence sum per Environmental sample

```{r}
sample_sums(physeq1_mar)
```

### Prune Environmental samples with less than 10K sequences

```{r}
sample_sums(physeq1_mar)<10000
physeq1_mar_lt10k <- prune_samples(sample_sums(physeq1_mar)<10000, physeq1_mar)
physeq1_mar_lt10k
sample_sums(physeq1_mar_lt10k)
sample_names(physeq1_mar_lt10k)
physeq1_mar_pruned <- prune_samples(sample_sums(physeq1_mar)>=10000, physeq1_mar)
sample_sums(physeq1_mar_pruned)
sample_names(physeq1_mar_pruned)
physeq1_mar_pruned
#removed 14 samples (previously 160 samples, now 146)
```

### Standardize number of reads to the median sequencing depth

```{r}
total = median(sample_sums(physeq1_mar_pruned))
#total == 74889
standf = function(x, t=total) round(t *(x / sum(x)))
physeq2 = transform_sample_counts(physeq1_mar_pruned, standf)
physeq2

```

```{r}
#rcurve(physeq2, add_sample_data = TRUE)
#p <- ggrare(physeq2, step = 500, color = "Zone", label = "Sample", se = FALSE)

sample_data(physeq2)
#TopNESVs <- names(sort(taxa_sums(physeq2), TRUE)[1:30])
#physeq2_30 <- prune_taxa(TopNESVs, physeq2$Species)
#print(physeq2_30)
```

### Barplots of normalized environmental samples and marine ESVs

```{r}
plot_bar(physeq2, fill = "Family")
```

```{r}
plot_bar(physeq2, fill = "Order")
```

### Heatmaps of normalized environmental samples and marine ESVs

```{r}
plot_heatmap(physeq2, taxa.label="Phylum")
```

### Alternative barplot formats

```{r}
plot_bar(physeq2, x= "Zone", fill = "Family")
```

```{r}
plot_bar(physeq2, x= "Zone", fill = "Family") + facet_wrap(~Cardinal_direction)
```

```{r}
#plot_net(physeq2, maxdist=0.4, color="Cardinal_direction", shape="Near_or_Offshore")
```

### Richness plots

```{r}
# plot_richness() function produces a ggplot object and can be ammended just like ggplot
# source color palette
source(file.path("./scripts/color_palette.R"))

Fig_richness <- plot_richness(physeq2, 
                              measures = c("Chao1", "Shannon"), 
                              x="Near_or_Offshore", 
                              color="Near_or_Offshore",
                              shape="Near_or_Offshore") +
  theme_light(base_size = 12) +
  scale_color_manual(values = near_offshore_colors) +
  labs(color = "Region",
       shape = "Region") +
  theme(axis.title.x =element_blank())

Fig_richness

ggsave(plot = Fig_richness, 
       device = "png", 
       filename = file.path("products/figures/Fig_richness_near_offshore.png"),
       dpi = 600,
       width = 6,
       height = 4,
       units = "in")

```

```{r}
plot_richness(physeq2, measures=c("Chao1", "Shannon"), x="Near_or_Offshore", color="Zone")
```

### Ordinations

```{r}
physeq2.ord <- ordinate(physeq2, "PCoA", "bray")
```

```{r}
# base plot ordination - other iterations are built on this object
po <- plot_ordination(physeq2, 
                      physeq2.ord, 
                      type = "samples", 
                      color = "Zone", 
                      shape = "Near_or_Offshore", 
                      title = "Nearshore & Offshore Samples")
po

jpeg(file="saving_plot1.jpeg")
```

```{r, echo=TRUE}
Fig_ord_near_off <- po +
  facet_wrap(~Near_or_Offshore) +
  scale_color_manual(values = zone_colors,
                     breaks = c("SHR", "LGN", "FRR", "AFZ", "DFZ", "NMS"),
                     guide = guide_legend(override.aes = list(size = 3, shape = c(16,16,16,17,17,17)))) +
  guides(shape = guide_legend(override.aes = list(size = 3, shape = c(1,2)))) +
  theme_light() +
  labs(shape = "Region") +
  coord_fixed()

Fig_ord_near_off
ggsave(plot = Fig_ord_near_off, 
       device = "png", 
       filename = file.path("products/figures/Fig_ord_near_offshore.png"),
       dpi = 600,
       width = 7,
       height = 3.5,
       units = "in")

### USE for Prelim Report
```

```{r}
po +facet_wrap(~Cardinal_direction)
```

```{r}
Fig_ord_near_off_grid <- po +
  facet_wrap(~factor(Zone, levels = c("SHR", "LGN", "FRR", "AFZ", "DFZ", "NMS"))) +
  scale_color_manual(values = zone_colors,
                     breaks = c("SHR", "LGN", "FRR", "AFZ", "DFZ", "NMS"),
                     guide = guide_legend(override.aes = list(size = 3, shape = c(16,16,16,17,17,17)))) +
  guides(shape = guide_legend(override.aes = list(size = 3, shape = c(1,2)))) +
  theme_light() +
  labs(shape = "Region") +
  coord_fixed()

Fig_ord_near_off_grid

ggsave(plot = Fig_ord_near_off_grid, 
       device = "png", 
       filename = file.path("products/figures/Fig_ord_near_offshore_grid.png"),
       dpi = 600,
       width = 7,
       height = 5,
       units = "in")
#ORDER BY NEARSHORE & OFFSHORE
###USE for Prelim Report
```

### Subset taxa

```{r}
sf = filter_taxa(physeq2, function(x) sd(x)/mean(x) > 3.0, TRUE)
sfAct = subset_taxa(sf, Class=="Actinopteri")
# create dataframe from phyloseq object
sfAct_df <- psmelt(sfAct)
sfMam = subset_taxa(sf, Class=="Mammalia")
sfCon = subset_taxa(sf, Class=="Chondrichthyes")
```

### Marine Actinopteri (Bony Fish) bar plot

```{r, cache=TRUE}
# library for pasting visual objects in grid layout
library(cowplot)
library(viridisLite)

# reorder s4 phyloseq object Sample data by Near_or_Offshore
# data_to_rearrange <- sfAct@sam_data$Sample
# data_to_order_by <- sfAct@sam_data$Near_or_Offshore
# ordering <- order(data_to_order_by)
# sfAct@sam_data$Sample <- data_to_rearrange[ordering]


fish_color <- viridis(n = 90, option = "turbo")

Fig_bony_fish <- plot_bar(sfAct, fill = "Family") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.line.x.bottom = element_blank(),
        axis.ticks.x = element_blank(),
        legend.position="bottom") +
  guides(fill = guide_legend(ncol=10)) +
  scale_y_continuous(expand = c(0,0)) +
  scale_fill_manual(values = fish_color)

# extract legend
bony_fish_legend <- cowplot::get_legend(Fig_bony_fish# + 
  # create some space to the left of the legend
 # theme(legend.box.margin = margin(0, 0, 0, 0))
)

# place figure without legend on grid
Fig_bony_fish_leg <- cowplot::plot_grid(
  Fig_bony_fish +
  theme(legend.position="none")
 )

# add legend to gird
Fig_bony_fish_leg2 <- cowplot::plot_grid(
  Fig_bony_fish_leg,
  bony_fish_legend,
  align = "v",
  nrow = 2,
  ncol = 1,
  rel_heights = c(3,1),
  scale =  1
) 

#Fig_bony_fish_leg2

ggsave(plot = Fig_bony_fish_leg2,
       device = "png",
       filename = file.path("products/figures/Fig_bony_fish.png"),
       dpi = 600,
       width = 7,
       height = 5,
       scale = 2,
       units = "in")
```

### Marine Mammals

```{r}
plot_bar(sfMam, fill = "Species")

jpeg(file="saving_plot2.jpeg")
plot_bar(sfAct, fill = "Family")
dev.off()
```

### Marine Chondrichthyes (Sharks & Rays)

```{r}
plot_bar(sfCon, fill = "Species")
```

### Top10

```{r}
OTUnames10 = names(sort(taxa_sums(sf), TRUE)[1:10])
sf10  = prune_taxa(OTUnames10,  sf)

sf10near = names(subset(sample_data(sf), Near_or_Offshore=="Nearshore"))
sf10off = names(subset(sample_data(sf), Near_or_Offshore=="Offshore"))

top10 <- names(sort(taxa_sums(sf), decreasing = TRUE)[1:10])

phyloseq::tax_table(sf)[top10,]
print(sf10near)
print(sf10off)


```

###Subsetting and pruning Nearshore and Offshore sample sets

```{r}
sample_variables(physeq2)

phyloseq::tax_table(sf10)[top10,]

sfNearshore <- subset_samples(sf, Near_or_Offshore == "Nearshore")
sfNearshore

sfOffshore <- subset_samples(sf, Near_or_Offshore == "Offshore")
sfOffshore

#test <- phyloseq::prune_samples(sample_sums(sfNearshore)>=1, sfNearshore)
#test
#sfNearshore

#test2 <- phyloseq::prune_samples(sample_sums(sfOffshore)>=1, sfOffshore)
#test2
#sfOffshore

sfNearshore <- phyloseq::prune_taxa(taxa_sums(sfNearshore)>=1, sfNearshore)
sfNearshore

sfOffshore <- phyloseq::prune_taxa(taxa_sums(sfOffshore)>=1, sfOffshore)
sfOffshore

sfNearshore
sfOffshore
```

###Family counts of physeq2 object (sf)

```{r}
get_taxa_unique(sf, "Family")
#93
get_taxa_unique(sfNearshore, "Family")
#79
get_taxa_unique(sfOffshore, "Family")
#53
```

### Genus counts of physeq2 object (sf)

```{r}
get_taxa_unique(sf, "Genus")
#260
get_taxa_unique(sfNearshore, "Genus")
#232
get_taxa_unique(sfOffshore, "Genus")
#83
```

### Species counts of physeq2 object (sf)

```{r}
get_taxa_unique(sf, "Species")
#389
get_taxa_unique(sfNearshore, "Species")
#346
get_taxa_unique(sfOffshore, "Species")
#81
```

###Top

```{r}
top5sf_species <- sort(tapply(taxa_sums(sf), tax_table(sf) [, "Family"], sum), decreasing = TRUE)[1:5]

names(sort(taxa_sums(sf), decreasing = TRUE)[1:10])

```

### Top Species

```{r}
devtools::install_github("gmteunisse/fantaxtic")
require("fantaxtic")

top10sf_species <- top_taxa(sf, 
                  tax_level = "Species",
                  n_taxa = 10,
                  grouping = "Near_or_Offshore")
top10sf_species
```

### Top Nearshore Species

```{r}
top10sfNear_species <- top_taxa(sfNearshore, 
                  tax_level = "Species",
                  n_taxa = 10)
top10sfNear_species
```

### Top Offshore Species

```{r}
top10sfOff_species <- top_taxa(sfOffshore, 
                  tax_level = "Species",
                  n_taxa = 10)
top10sfOff_species
```
